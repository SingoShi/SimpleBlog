Title: Effective C++读书笔记（45-48）
Date: 2014/03/27
Category: C++
Tags: 读书笔记 Effective C++
Author: Singo
Summary: 
Status: public

# 45.使用成员函数模板接受所有类型

- 智能指针为例，`template<typename T> class SmartPtr`
- 虽然`class A`和`class B`有继承关系，但是具现化之后的`SmartPtr<A>`和`SmartPtr<B>`没有继承关系
- 所以需要定义一个成员函数（构造）模板来处理更泛化的构造
- 这个泛化的构造函数模板并没有声明为`explict`。这是因为原始的基类指针，派生类指针转换就是隐式的
- 这种泛化的构造需要约束，可以让这个智能指针类 **has a** T\*的成员变量指向它持有的对象，使用成员初始化列表初始化这个成员变量。这样不兼容的类型转换将不能编译成功。
- 成员函数模板不限于构造函数
- 成员函数模板不改变语言规则，泛化的构造函数模板并不阻止编译器默认生成一个拷贝构造函数

# 46.当需要类型转换是请在模板内定义非成员函数

- 模板函数的参数推导，编译器不会做隐式转换。
- 可以在模板类中声明一个`friend`的模板函数，当模板类具现化时，这个`friend`的模板函数也被具现化出来
- 此时函数声明有了，编译没问题，链接报错，因为模板函数实现没有具现化
- 可以把实现放到模板类中
- 类中定义的函数默认为`inline`，如果是复杂的实现，出现代码膨胀
- 可以定义一个辅助函数，解决实现放到模板类中带来`inline`副作用

# 47.使用`traits class`表现类型信息

- traits class本身是个类模板
- 在类模板使用typedef关联一个traits class，这样做并不会修改的类的数据结构，是泛型编程中特有的。非泛型编程变现类信息可以通过增加类型字段的方式。
- 模板类中的函数需要根据模板的类型参数做不同的实现，例如：

		template<T>
		void do() {
			if (T is something)
				doSomething()
			elif (T is other)
				doOther()
		}

- 使用`typeid`，但是有问题：1. 类型check本来在编译就能搞定的延后到运行时，2.编译会有问题
- 可以使用重载
		
		template<T>
		void do() {
			doThing(traits<T>);
		}
		void doThing(traits<something>) {
			...
		}
		void doThing(traits<other>) {
			...
		}

# 48.模板元编程

- 模板元编程是指执行于编译器内的程序
- 好处：1.让某些事情更容易（没例子反正我是相信的），2.让某些运行时做的事情转移到编译期，一方面提高效率，另一方面错误提早发现。
- 模板元编程被证明是图灵完全机。
- 模板具现化时的运算替代了运行时的运算，提高了效率
- 缺点语法不直观，缺少支撑工具如调试等，编译器对模板递归有限制